<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.14">
  <POU Name="FB_StringBuilderEx_Any" Id="{a3b9c09e-cbc8-08a7-18f4-a792c9208864}" SpecialFunc="None">
    <Declaration><![CDATA[// An extension to FB_StringBuilderBase. The ethods acceppt ANY data type as entry. Values are converted internally.
FUNCTION_BLOCK FB_StringBuilderEx_Any IMPLEMENTS I_StringBuilderEx_Any
VAR
	_stringBuilderBase	: FB_StringBuilderBase;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="AddAny" Id="{b9fd09fd-5727-0ce3-0bbd-b877aa1783cd}">
      <Declaration><![CDATA[(* Adds the variable of any data type to the sequence. Conversion is done automatically from within. 
Returns I_StringBuilderEx_Any for further string building capability.

Some extra info: 
	- BOOL and BIT will have the string converted to 'TRUE' and 'FALSE' respectively.
	- BYTE, WORD, DWORD and LWORD will be converted without any additional options. Use AddAnyBit method for these instead!
	- REAL and LREAL will be added as T_MaxString values. Please use AddAnyReal method for these instead.*)

METHOD AddAny : I_StringBuilderEx_Any
VAR_INPUT
	anyVar	: ANY;
END_VAR

VAR
	result	: Tc2_System.T_MaxString;
	ptrWstring	: POINTER TO WSTRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE TO_INT(anyVar.TypeClass) OF 
	IBaseLibrary.TypeClass.TYPE_BOOL:
		IF Tc2_Utilities.PBOOL_TO_BOOL(anyVar.pValue) = TRUE THEN
			result :=	'TRUE';
		ELSE
			result := 'FALSE';
		END_IF
		
	IBaseLibrary.TypeClass.TYPE_BYTE: 
		result := BYTE_TO_STRING(Tc2_Utilities.PBYTE_TO_BYTE(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_DATE:
		result := DATE_TO_STRING(Tc2_Utilities.PDATE_TO_DATE(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_DATEANDTIME:
		result := DT_TO_STRING(Tc2_Utilities.PDT_TO_DT(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_DINT:
		result := DINT_TO_STRING(Tc2_Utilities.PDINT_TO_DINT(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_DWORD:
		result := DWORD_TO_STRING(Tc2_Utilities.PDWORD_TO_DWORD(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_ENUM:
		result := TO_STRING(anyVar.pValue^);
	
	IBaseLibrary.TypeClass.TYPE_INT:
		result := INT_TO_STRING(Tc2_Utilities.PINT_TO_INT(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_LINT:
		result := LINT_TO_STRING(Tc2_Utilities.PLINT_TO_LINT(anyVar.pValue));
		
	IBaseLibrary.TypeClass.TYPE_LREAL:
		result := LREAL_TO_STRING(Tc2_Utilities.PLREAL_TO_LREAL(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_LTIME:
		result := LTIME_TO_STRING(Tc2_Utilities.PLTIME_TO_LTIME(anyVar.pValue));
		
	IBaseLibrary.TypeClass.TYPE_LWORD:
		result := LWORD_TO_STRING(Tc2_Utilities.PLWORD_TO_LWORD(anyVar.pValue));
		
	IBaseLibrary.TypeClass.TYPE_REAL:
		result := REAL_TO_STRING(Tc2_Utilities.PREAL_TO_REAL(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_SINT:
		result := SINT_TO_STRING(Tc2_Utilities.PSINT_TO_SINT(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_STRING:
		result := TO_STRING(Tc2_Utilities.PSTRING_TO_STRING(anyVar.pValue));
		
	IBaseLibrary.TypeClass.TYPE_TIME:
		result := TIME_TO_STRING(Tc2_Utilities.PTIME_TO_TIME(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_TIMEOFDAY:
		result := TOD_TO_STRING(Tc2_Utilities.PTOD_TO_TOD(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_UDINT:
		result := UDINT_TO_STRING(Tc2_Utilities.PUDINT_TO_UDINT(anyVar.pValue));		
	
	IBaseLibrary.TypeClass.TYPE_UINT:
		result := UINT_TO_STRING(Tc2_Utilities.PUINT_TO_UINT(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_ULINT:
		result := ULINT_TO_STRING(Tc2_Utilities.PULINT_TO_ULINT(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_USINT:
		result := USINT_TO_STRING(Tc2_Utilities.PUSINT_TO_USINT(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_WORD:
		result := WORD_TO_STRING(Tc2_Utilities.PWORD_TO_WORD(anyVar.pValue));
	
	IBaseLibrary.TypeClass.TYPE_WSTRING:
		ptrWstring := anyVar.pValue;
		result := WSTRING_TO_STRING(ptrWstring^);
		
	ELSE
		result := TO_STRING(anyVar.pValue^);
	
END_CASE

_stringBuilderBase.AddString(result);
AddAny := THIS^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddAnyBit" Id="{b8b5349f-82bc-0ac0-2894-a1005cd28a23}">
      <Declaration><![CDATA[// Adds a variable of type ANY_BIT to the string generating sequence, based on the provided parameters.
// This includes: BYTE, WORD, DWORD, LWORD, 
METHOD AddAnyBit : I_StringBuilderEx_Any
VAR_INPUT
	anyBit					: ANY_BIT;				// Value to be converterd
	option					: E_AddAnyBitOptions;	// Select how the value is converter
	lowerCase				: BOOL;					// If hexadecimal option is selected, the result string can be converted to either lower or upper case
	displayedDigitsCount	: INT;					// This determines how many digits are to be displayed. If actual digits count is lower, the string is filled with zeros from the left side. If left at 0, the result string will be an empty string!
	addNotation				: BOOL;					// If this is set to TRUE, a notation will be prepended: (DEC)10, (BIN)10, (HEX)10, (OCT)10
END_VAR
VAR
	result : Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[{warning 'Create tests to verify functionality!'}
CASE anyBit.TypeClass OF
	__SYSTEM.TYPE_CLASS.TYPE_WORD:
		CASE option OF
			E_AddAnyBitOptions.BINARY:
				result := Tc2_Utilities.WORD_TO_BINSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
				
			E_AddAnyBitOptions.DECIMAL:
				result := Tc2_Utilities.WORD_TO_DECSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
				
			E_AddAnyBitOptions.HEXADECIMAL:
				result := Tc2_Utilities.WORD_TO_HEXSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount,
					bLoCase := lowerCase);
				
			E_AddAnyBitOptions.OCTAL:
				result := Tc2_Utilities.WORD_TO_OCTSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
		END_CASE
		
	IBaseLibrary.TypeClass.TYPE_BYTE:
		CASE option OF
			E_AddAnyBitOptions.BINARY:
				result := Tc2_Utilities.BYTE_TO_BINSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
				
			E_AddAnyBitOptions.DECIMAL:
				result := Tc2_Utilities.BYTE_TO_DECSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
				
			E_AddAnyBitOptions.HEXADECIMAL:
				result := Tc2_Utilities.BYTE_TO_HEXSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount,
					bLoCase := lowerCase);
				
			E_AddAnyBitOptions.OCTAL:
				result := Tc2_Utilities.BYTE_TO_OCTSTR(
					in := anyBit.pValue^, 
					iPrecision := displayedDigitsCount);
		END_CASE
	
	IBaseLibrary.TypeClass.TYPE_DWORD:
		CASE option OF
			E_AddAnyBitOptions.BINARY:
				result := Tc2_Utilities.WORD_TO_BINSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
				
			E_AddAnyBitOptions.DECIMAL:
				result := Tc2_Utilities.WORD_TO_DECSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
				
			E_AddAnyBitOptions.HEXADECIMAL:
				result := Tc2_Utilities.WORD_TO_HEXSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount,
					bLoCase := lowerCase);
				
			E_AddAnyBitOptions.OCTAL:
				result := Tc2_Utilities.WORD_TO_OCTSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
		END_CASE
	
	IBaseLibrary.TypeClass.TYPE_LWORD:
		CASE option OF
			E_AddAnyBitOptions.BINARY:
				result := Tc2_Utilities.LWORD_TO_BINSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
				
			E_AddAnyBitOptions.DECIMAL:
				result := Tc2_Utilities.LWORD_TO_DECSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
				
			E_AddAnyBitOptions.HEXADECIMAL:
				result := Tc2_Utilities.LWORD_TO_HEXSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount,
					bLoCase := lowerCase);
				
			E_AddAnyBitOptions.OCTAL:
				result := Tc2_Utilities.LWORD_TO_OCTSTR(
					in := anyBit.pValue^,
					iPrecision := displayedDigitsCount);
		END_CASE
END_CASE

IF addNotation THEN
	CASE option OF
		E_AddAnyBitOptions.BINARY:
			result := Tc2_Standard.CONCAT('(BIN)', result);
			
		E_AddAnyBitOptions.DECIMAL:
			result := Tc2_Standard.CONCAT('(DEC)', result);
		
		E_AddAnyBitOptions.HEXADECIMAL:
			result := Tc2_Standard.CONCAT('(HEX)', result);
		
		E_AddAnyBitOptions.OCTAL:
			result := Tc2_Standard.CONCAT('(OCT)', result);
	END_CASE
END_IF

_stringBuilderBase.AddString(result);
AddAnyBit := THIS^;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddAnyReal" Id="{c64b3256-4480-0cfd-3dd0-b1062a076d36}">
      <Declaration><![CDATA[// Adds any REAL or LREAL value to the generating string sequence.
// Please note that REAL values will ALWAYS be automatically rounded on 3rd decimal digit.
// Anything after it will be whatever TwinCAT decides to do.
METHOD AddAnyReal : I_StringBuilderEx_Any
VAR_INPUT
	anyReal		: ANY_REAL;	// Value to be converter
	precision	: INT;		// Precision of decimal digits
	round		: BOOL;		// Rounding of the last displayed digit
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF anyReal.diSize = SIZEOF(REAL) THEN
	// REAL
	_stringBuilderBase.AddString(
		Tc2_Utilities.LREAL_TO_FMTSTR(
			in := REAL_TO_LREAL(Tc2_Utilities.PREAL_TO_REAL(anyReal.pValue)),
			iPrecision := precision, 
			bRound := round));
		
ELSE
	// LREAL
	_stringBuilderBase.AddString(Tc2_Utilities.LREAL_TO_FMTSTR(
		in := Tc2_Utilities.PLREAL_TO_LREAL(anyReal.pValue),
		iPrecision := precision,
		bRound := round));	
END_IF

AddAnyReal := THIS^;


	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Create" Id="{b37645ef-ea8f-0e2e-3ae1-fde44b144eb3}">
      <Declaration><![CDATA[METHOD Create : T_MaxString
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Create := _stringBuilderBase.Create();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{8e8460a6-a7df-0ad5-1839-d7ff2c62e7f2}">
      <Declaration><![CDATA[(* Reset the string build sequence, clear any string built so far.*)
METHOD Reset : I_StringBuilderEx_Any
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_stringBuilderBase.Reset();
Reset := THIS^;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>