<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_DirectoryUtilities" Id="{db17547a-e0e3-0247-1987-14342fc00f3f}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_DirectoryUtilities IMPLEMENTS I_Directory
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="DeleteFilesCreatedBefore" Id="{26842599-0472-011e-0d6e-8b713977b88d}">
      <Declaration><![CDATA[// Deletes matching files in the directory that were created before the provided date.
METHOD DeleteFilesCreatedBefore : BOOL
VAR_INPUT
	path				: Tc2_System.T_MaxString;	// Path to where the deletion should be performed
	fileNameContains	: Tc2_System.T_MaxString;	// Some characters that the file name should containt
	netId				: Tc2_System.T_AmsNetID;	// NetId where the search should occurr
	thresholdDate		: DT;	// If created before this date, the file will be deleted.
END_VAR
VAR_OUTPUT
	error			: BOOL;
	errorInfo		: ZigaLibs_Core.ST_AdsError;	
	deletedFiles	: ARRAY[0..100] OF Tc2_System.T_MaxString;	// A list of deleted items, as T_MaxString (file names).
END_VAR

VAR_INST
	files				: ARRAY[0..100] OF Tc2_Utilities.ST_FindFileEntry;
	currentFile			: ST_FindFileEntry;
	state				: E_DeleteFilesByDateState;
	fileUtilities		: FB_FileUtilities;
	deleteFilesLocal	: ARRAY[0..100] OF Tc2_System.T_MaxString;
	fileIndex			: DINT;
END_VAR
VAR
	timeOfCreation		: DT;
	deletedFileIndex	: ZigaLibs_Core.T_ArrayIndexer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE state OF
	E_DeleteFilesByDateState.START:
		fileIndex := 0;
		IF THIS^.ListAll(path := path, netId := netId, items := files, error => error, errorInfo => errorInfo) THEN
			state := E_DeleteFilesByDateState.GET_FILE;
		END_IF
	
	E_DeleteFilesByDateState.GET_FILE:
		// Iterate the array, delete files that match the criteria - name contains the string and it was created before date
		
		IF fileIndex <= 100 AND fileIndex >= 0 THEN
			currentFile := files[fileIndex];
			fileIndex := fileIndex + 1;
			IF currentFile.sFileName <> '' AND_THEN Tc2_Standard.FIND(currentFile.sFileName, fileNameContains) <> 0 THEN
				// Matching file found, check date of creation
				timeOfCreation := Tc2_Utilities.FILETIME_TO_DT(currentFile.creationTime);
				IF timeOfCreation < thresholdDate THEN
					// Date is lower than provided date threshold
					state := E_DeleteFilesByDateState.WAIT_FOR_DELETE;
				END_IF
			END_IF 
		ELSE
			deletedFiles := deleteFilesLocal;
			state := E_DeleteFilesByDateState.START;
			DeleteFilesCreatedBefore := TRUE;
		END_IF
	
	E_DeleteFilesByDateState.WAIT_FOR_DELETE:
		IF fileUtilities.Delete(
			path, 
			currentFile.sFileName, 
			netId, 
			error => error, errorInfo => errorInfo) 
		THEN
			IF error THEN
				DeleteFilesCreatedBefore := TRUE;
				RETURN;
			END_IF
			ZigaLibs_Core.ArrayHelper.ShiftUp(deletedFiles, deleteFilesLocal[0]);
			deleteFilesLocal[0] := currentFile.sFileName;
			state := E_DeleteFilesByDateState.GET_FILE;
		END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Exists" Id="{a4c8d70e-8749-06d7-1c3a-54dc3524e2cb}">
      <Declaration><![CDATA[(* Looks if the provided directory exists on the disk.
 Returns TRUE when done
 Result can be found in the output directoryExists.*)
METHOD Exists : BOOL
VAR_INPUT
	(* Path to the directory that will be searched.*)
	directory	: Tc2_System.T_MaxString;
	(* NetId where to search.*)
	netId	: Tc2_System.T_AmsNetID;
END_VAR
VAR_OUTPUT
	(* TRUE if it exists, else FALSE. Only valid after method returns TRUE.*)
	directoryExists	: BOOL;
END_VAR

VAR
	foundItems 			: ARRAY[0..100] OF Tc2_Utilities.ST_FindFileEntry;
	currentItemIndex	: ZigaLibs_Core.T_ArrayIndexer;
	currentItem			: Tc2_Utilities.ST_FindFileEntry;
	directoryName		: Tc2_System.T_MaxString;
	charPosiiton		: INT;
	itemName			: Tc2_System.T_MaxString;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// List all the items...
IF THIS^.ListAll(path := directory, netId := netId, items := foundItems) THEN
	// Split the path into directories
	
	WHILE Tc2_Standard.FIND(STR1 := directoryName, STR2 := '.') <> 0 DO
		charPosiiton := Tc2_Standard.FIND(directoryName, '.');
		directoryName := Tc2_Standard.DELETE(directoryName, charPosiiton, 1);
	END_WHILE

	// Iterate the returned items and check if it is directory and the name is correct. Exit on success.
	FOR currentItemIndex := 0 TO 100 BY 1 DO
		currentItem := foundItems[currentItemIndex];
		IF currentItem.fileAttributes.bDirectory AND_THEN
			currentItem.sFileName = directoryName
		THEN
			directoryExists := TRUE;
			EXIT;
		END_IF
	END_FOR
END_IF

Exists := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ListAll" Id="{f540edc2-550e-001a-055a-40e0b36680b2}">
      <Declaration><![CDATA[(* Looks in the directory `path` and iterates the content. 
 When method returns TRUE, the collection of items is found in the result I_Collection.*)
METHOD ListAll : BOOL
VAR_INPUT
	path	: Tc2_System.T_MaxString;	// Path to the directory that will be searched.
	netId	: Tc2_System.T_AmsNetID;	// NetId where to search.
END_VAR

VAR_IN_OUT
	items	: ARRAY[*] OF Tc2_Utilities.ST_FindFileEntry;	// Collection of found files in the provided location	
END_VAR

VAR_OUTPUT
	error		: BOOL;	// Will be true if an error occurs while executing the file query
	errorInfo	: ZigaLibs_Core.ST_AdsError;	// Error information will be provided here
END_VAR

VAR_INST
	fbFindFileEntries	: Tc2_Utilities.FB_EnumFindFileEntry;
	eGetFilesState		: E_GetFilesState;
	itemsArrayIndex		: ZigaLibs_Core.T_ArrayIndexer;
END_VAR

VAR
	varInfo	: ZigaLibs_Core.T_VarInfo;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eGetFilesState OF
	
	E_GetFilesState.READY:
		fbFindFileEntries(bExecute := FALSE, 
		eCmd := Tc2_Utilities.E_EnumCmdType.eEnumCmd_First);
		// Clear the array when startin
		Tc2_System.MEMSET(destAddr := ADR(items[0]), fillByte := 0, n := SIZEOF(items));
		itemsArrayIndex := 0;	
		eGetFilesState := E_GetFilesState.START;

	E_GetFilesState.START:
		error := FALSE;
		errorInfo.Code := 0;
		errorInfo.Source := '';
		
		// Path/* returns all entries
		fbFindFileEntries(bExecute := TRUE, sNetId := netId,
			sPathName := Utilities.Path.Generate()
				.Join(path)
				.AddWildcard().Asterisk(left := '', right :='')
				.Create());
			
		eGetFilesState := E_GetFilesState.AWAIT_RESULT;
	
	E_GetFilesState.AWAIT_RESULT:
		fbFindFileEntries(bExecute := FALSE);
		
		IF fbFindFileEntries.bError THEN
			eGetFilesState := E_GetFilesState.ERROR;
			RETURN;
		END_IF
		
		IF fbFindFileEntries.bBusy THEN
			RETURN;
		END_IF
		
		IF NOT fbFindFileEntries.bEOE AND (itemsArrayIndex <= UPPER_BOUND(items, 1)) THEN
			items[itemsArrayIndex] := fbFindFileEntries.stFindFile;
			itemsArrayIndex := itemsArrayIndex + 1;
			fbFindFileEntries.eCmd := Tc2_Utilities.E_EnumCmdType.eEnumCmd_Next;
			eGetFilesState := E_GetFilesState.START;
			RETURN;
		END_IF
		
		eGetFilesState := E_GetFilesState.ALL_FILES_FOUND;
	
	E_GetFilesState.ALL_FILES_FOUND:
		ListAll := TRUE;
		eGetFilesState := E_GetFilesState.READY;
		
	E_GetFilesState.ERROR:
		error := TRUE;
		errorInfo.Code := TcError.ToAdsErrorCode(fbFindFileEntries.nErrID);
		varInfo := __VARINFO(fbFindFileEntries);
		errorInfo.Source := varInfo.Symbol;
		
		ListAll := TRUE;
		eGetFilesState := E_GetFilesState.READY;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="ListFiles" Id="{7a70de90-771b-0602-06e3-6e7ed61d5525}">
      <Declaration><![CDATA[(* Looks in the directory `path` and iterates the content. 
 When method returns TRUE, the collection of files is found in the result I_Collection.*)
METHOD ListFiles : BOOL
VAR_INPUT
	path	: Tc2_System.T_MaxString;	// Path to the directory that will be searched.
	netId	: Tc2_System.T_AmsNetID;	// NetId where to search.
END_VAR

VAR_IN_OUT
	files	: ARRAY[*] OF Tc2_System.T_MaxString;	// Collection of found files in the provided location.
END_VAR

VAR_OUTPUT
	error		: BOOL;	// Will be true if an error occurs while executing the file query
	errorInfo	: ZigaLibs_Core.ST_AdsError;	// Error information will be provided here
END_VAR

VAR_INST
	fbFindFileEntries	: Tc2_Utilities.FB_EnumFindFileEntry;
	eGetFilesState		: E_GetFilesState;
	filesArrayIndex		: ZigaLibs_Core.T_ArrayIndexer;
END_VAR

VAR
	varInfo	: ZigaLibs_Core.T_VarInfo;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eGetFilesState OF
	
	E_GetFilesState.READY:
		fbFindFileEntries(bExecute := FALSE, 
			eCmd := Tc2_Utilities.E_EnumCmdType.eEnumCmd_First);
		Tc2_System.MEMSET(destAddr := files, fillByte := 0, n := SIZEOF(files));		
		filesArrayIndex := 0;
		eGetFilesState := E_GetFilesState.START;

	E_GetFilesState.START:
		error := FALSE;
		errorInfo.Code := 0;
		errorInfo.Source := '';
		
		// Path/*.* returns all files
		fbFindFileEntries(bExecute := TRUE, sNetId := netId,
			sPathName := Utilities.Path.Generate()
				.Join(path)
				.AddWildcard().Asterisk('','')
				.AddWildcard().Asterisk('.', '')
				.Create());
			
		eGetFilesState := E_GetFilesState.AWAIT_RESULT;
	
	E_GetFilesState.AWAIT_RESULT:
		fbFindFileEntries(bExecute := FALSE);
		
		IF fbFindFileEntries.bError THEN
			eGetFilesState := E_GetFilesState.ERROR;
			RETURN;
		END_IF
		
		IF fbFindFileEntries.bBusy THEN
			RETURN;
		END_IF
		
		IF NOT fbFindFileEntries.bEOE AND (filesArrayIndex <= UPPER_BOUND(files, 1)) THEN
			files[filesArrayIndex] := fbFindFileEntries.stFindFile.sFileName;
			filesArrayIndex := filesArrayIndex + 1;
			fbFindFileEntries.eCmd := Tc2_Utilities.E_EnumCmdType.eEnumCmd_Next;
			eGetFilesState := E_GetFilesState.START;
			RETURN;
		END_IF
		
		eGetFilesState := E_GetFilesState.ALL_FILES_FOUND;
	
	E_GetFilesState.ALL_FILES_FOUND:
		ListFiles := TRUE;
		eGetFilesState := E_GetFilesState.READY;
		
	E_GetFilesState.ERROR:
		error := TRUE;
		errorInfo.Code := TcError.ToAdsErrorCode(fbFindFileEntries.nErrID);
		varInfo := __VARINFO(fbFindFileEntries);
		errorInfo.Source := varInfo.Symbol;
		
		ListFiles := TRUE;
		eGetFilesState := E_GetFilesState.READY;
END_CASE]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>